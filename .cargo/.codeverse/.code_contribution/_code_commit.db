{
  "range-cache-file:///t%3A/interview/web%20framework：vue3.md": "[{\"originRange\":{\"start\":{\"line\":52,\"character\":0},\"end\":{\"line\":52,\"character\":27}},\"modifyRange\":{\"start\":{\"line\":52,\"character\":0},\"end\":{\"line\":52,\"character\":27}},\"action\":\"None\",\"isLine\":false,\"originText\":\"### 2.1. ref 和 reactive 的区别\",\"originAcceptText\":\"### 2.1. ref 和 reactive 的区别\",\"originTextLength\":27,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":52,\"character\":27},\"end\":{\"line\":54,\"character\":41}},\"modifyRange\":{\"start\":{\"line\":52,\"character\":27},\"end\":{\"line\":54,\"character\":41}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n* ref 是一个对象，reactive 是一个对象或数组。\\\\n* ref 可以直接访问其 value 属性，reactive 直接访问属性即可。\",\"originAcceptText\":\"\\n\\n* ref 是一个对象，reactive 是一个对象或数组。\\n* ref 可以直接访问其 value 属性，reactive 直接访问属性即可。\",\"originTextLength\":74,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":55,\"character\":41},\"end\":{\"line\":57,\"character\":31}},\"modifyRange\":{\"start\":{\"line\":55,\"character\":41},\"end\":{\"line\":57,\"character\":31}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n* ref 是浅响应式，reactive 是深度响应式。\\\\n* ref 不支持数组的索引直接赋值，reactive 支持。\",\"originAcceptText\":\"\\n* ref 是浅响应式，reactive 是深度响应式。\\n* ref 不支持数组的索引直接赋值，reactive 支持。\",\"originTextLength\":61,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":57,\"character\":31},\"end\":{\"line\":58,\"character\":20}},\"modifyRange\":{\"start\":{\"line\":57,\"character\":31},\"end\":{\"line\":58,\"character\":20}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n### 2.2. ref 的底层实现原理\",\"originAcceptText\":\"\\n\\n### 2.2. ref 的底层实现原理\",\"originTextLength\":22,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":110,\"character\":0},\"end\":{\"line\":110,\"character\":40}},\"modifyRange\":{\"start\":{\"line\":110,\"character\":0},\"end\":{\"line\":110,\"character\":40}},\"action\":\"None\",\"isLine\":false,\"originText\":\"* 解决原始值的响应式问题：ref 可以将原始值包装成对象，使其具备响应式特性。\",\"originAcceptText\":\"* 解决原始值的响应式问题：ref 可以将原始值包装成对象，使其具备响应式特性。\",\"originTextLength\":40,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":110,\"character\":40},\"end\":{\"line\":112,\"character\":43}},\"modifyRange\":{\"start\":{\"line\":110,\"character\":40},\"end\":{\"line\":112,\"character\":43}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n* 解决对象属性动态添加/删除问题：reactive 可以监听对象属性的动态变化。\\\\n* 解决数组索引修改和 length 变化问题：reactive 可以监听数组的变化。\",\"originAcceptText\":\"\\n* 解决对象属性动态添加/删除问题：reactive 可以监听对象属性的动态变化。\\n* 解决数组索引修改和 length 变化问题：reactive 可以监听数组的变化。\",\"originTextLength\":86,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":112,\"character\":43},\"end\":{\"line\":113,\"character\":43}},\"modifyRange\":{\"start\":{\"line\":112,\"character\":43},\"end\":{\"line\":113,\"character\":43}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n## 3. 请解释Vue3的响应式系统是如何实现的？它与Vue2的响应式系统有何不同？\",\"originAcceptText\":\"\\n\\n## 3. 请解释Vue3的响应式系统是如何实现的？它与Vue2的响应式系统有何不同？\",\"originTextLength\":45,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":114,\"character\":43},\"end\":{\"line\":115,\"character\":23}},\"modifyRange\":{\"start\":{\"line\":114,\"character\":43},\"end\":{\"line\":115,\"character\":23}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n### 3.1. Vue3的响应式系统实现原理\",\"originAcceptText\":\"\\n\\n### 3.1. Vue3的响应式系统实现原理\",\"originTextLength\":25,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":116,\"character\":23},\"end\":{\"line\":117,\"character\":64}},\"modifyRange\":{\"start\":{\"line\":116,\"character\":23},\"end\":{\"line\":117,\"character\":64}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\nVue3的响应式系统基于Proxy和ES6的Proxy API实现，通过拦截对象属性的访问和修改，实现对数据的响应式追踪和更新。\",\"originAcceptText\":\"\\n\\nVue3的响应式系统基于Proxy和ES6的Proxy API实现，通过拦截对象属性的访问和修改，实现对数据的响应式追踪和更新。\",\"originTextLength\":66,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":118,\"character\":64},\"end\":{\"line\":119,\"character\":29}},\"modifyRange\":{\"start\":{\"line\":118,\"character\":64},\"end\":{\"line\":119,\"character\":29}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n### 3.2. Vue3的响应式系统与Vue2的不同之处\",\"originAcceptText\":\"\\n\\n### 3.2. Vue3的响应式系统与Vue2的不同之处\",\"originTextLength\":31,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":115,\"character\":0},\"end\":{\"line\":115,\"character\":19}},\"modifyRange\":{\"start\":{\"line\":115,\"character\":0},\"end\":{\"line\":115,\"character\":19}},\"action\":\"None\",\"isLine\":false,\"originText\":\"### 3.1. shallowRef\",\"originAcceptText\":\"### 3.1. shallowRef\",\"originTextLength\":19,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":115,\"character\":19},\"end\":{\"line\":116,\"character\":81}},\"modifyRange\":{\"start\":{\"line\":115,\"character\":19},\"end\":{\"line\":116,\"character\":81}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\nshallowRef 用于创建一个浅响应式的 ref 对象。与 ref 不同，shallowRef 不会对嵌套对象进行深度响应式处理，而是直接将原始值包装成对象。\",\"originAcceptText\":\"\\n\\nshallowRef 用于创建一个浅响应式的 ref 对象。与 ref 不同，shallowRef 不会对嵌套对象进行深度响应式处理，而是直接将原始值包装成对象。\",\"originTextLength\":83,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":117,\"character\":81},\"end\":{\"line\":119,\"character\":47}},\"modifyRange\":{\"start\":{\"line\":117,\"character\":81},\"end\":{\"line\":119,\"character\":47}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n```js\\\\nconst shallowRefObj = shallowRef({ count: 0 });\",\"originAcceptText\":\"\\n\\n```js\\nconst shallowRefObj = shallowRef({ count: 0 });\",\"originTextLength\":55,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":127,\"character\":3},\"end\":{\"line\":127,\"character\":5}},\"modifyRange\":{\"start\":{\"line\":127,\"character\":3},\"end\":{\"line\":127,\"character\":5}},\"action\":\"None\",\"isLine\":false,\"originText\":\"js\",\"originAcceptText\":\"js\",\"originTextLength\":2,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":212,\"character\":0},\"end\":{\"line\":214,\"character\":103}},\"modifyRange\":{\"start\":{\"line\":212,\"character\":0},\"end\":{\"line\":214,\"character\":103}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n官方不建议在应用代码中直接使用 getCurrentInstance 函数，因为它可能会导致代码的耦合性增加，不利于代码的维护和扩展。\\\\n此外， getCurrentInstance 函数返回的是当前组件实例的引用，而不是组件实例本身。如果在组件实例中直接访问 getCurrentInstance 函数返回的实例，可能会导致代码的可读性降低。\",\"originAcceptText\":\"\\n官方不建议在应用代码中直接使用 getCurrentInstance 函数，因为它可能会导致代码的耦合性增加，不利于代码的维护和扩展。\\n此外， getCurrentInstance 函数返回的是当前组件实例的引用，而不是组件实例本身。如果在组件实例中直接访问 getCurrentInstance 函数返回的实例，可能会导致代码的可读性降低。\",\"originTextLength\":172,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":214,\"character\":103},\"end\":{\"line\":215,\"character\":44}},\"modifyRange\":{\"start\":{\"line\":214,\"character\":103},\"end\":{\"line\":215,\"character\":44}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n因此，官方建议在组件内部使用 provide 和 inject 来进行数据的传递和共享。\",\"originAcceptText\":\"\\n因此，官方建议在组件内部使用 provide 和 inject 来进行数据的传递和共享。\",\"originTextLength\":45,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":284,\"character\":40},\"end\":{\"line\":285,\"character\":80}},\"modifyRange\":{\"start\":{\"line\":284,\"character\":40},\"end\":{\"line\":285,\"character\":80}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n4. 控制执行顺序 ：调度器可以控制副作用函数的执行顺序，比如可以将一些副作用函数安排在 DOM 更新之后执行，确保在操作 DOM 时，DOM 已经是最新状态。\",\"originAcceptText\":\"\\n4. 控制执行顺序 ：调度器可以控制副作用函数的执行顺序，比如可以将一些副作用函数安排在 DOM 更新之后执行，确保在操作 DOM 时，DOM 已经是最新状态。\",\"originTextLength\":81,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":409,\"character\":115},\"end\":{\"line\":410,\"character\":71}},\"modifyRange\":{\"start\":{\"line\":409,\"character\":115},\"end\":{\"line\":410,\"character\":71}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Pinia ：Pinia 的 API 设计更加简洁，直接使用 state 和 actions ，不需要额外的概念。这使得代码更易读和维护。\",\"originAcceptText\":\"\\n- Pinia ：Pinia 的 API 设计更加简洁，直接使用 state 和 actions ，不需要额外的概念。这使得代码更易读和维护。\",\"originTextLength\":72,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":410,\"character\":71},\"end\":{\"line\":412,\"character\":32}},\"modifyRange\":{\"start\":{\"line\":410,\"character\":71},\"end\":{\"line\":412,\"character\":32}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n### 2. 更好的类型推断\\\\n- Vuex ：Vuex 的类型推断相对较弱，需要手动定义类型。\",\"originAcceptText\":\"\\n### 2. 更好的类型推断\\n- Vuex ：Vuex 的类型推断相对较弱，需要手动定义类型。\",\"originTextLength\":48,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":412,\"character\":32},\"end\":{\"line\":413,\"character\":65}},\"modifyRange\":{\"start\":{\"line\":412,\"character\":32},\"end\":{\"line\":413,\"character\":65}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Pinia ：Pinia 的类型推断更加智能，能够自动推断出 state 和 actions 的类型，减少了手动定义的工作量。\",\"originAcceptText\":\"\\n- Pinia ：Pinia 的类型推断更加智能，能够自动推断出 state 和 actions 的类型，减少了手动定义的工作量。\",\"originTextLength\":66,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":413,\"character\":65},\"end\":{\"line\":415,\"character\":39}},\"modifyRange\":{\"start\":{\"line\":413,\"character\":65},\"end\":{\"line\":415,\"character\":39}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n### 3. 更灵活的状态管理\\\\n- Vuex ：Vuex 主要用于全局状态管理，对于组件内的状态管理相对较弱。\",\"originAcceptText\":\"\\n### 3. 更灵活的状态管理\\n- Vuex ：Vuex 主要用于全局状态管理，对于组件内的状态管理相对较弱。\",\"originTextLength\":56,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":415,\"character\":39},\"end\":{\"line\":416,\"character\":50}},\"modifyRange\":{\"start\":{\"line\":415,\"character\":39},\"end\":{\"line\":416,\"character\":50}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Pinia ：Pinia 可以在组件内使用，支持在组件内部管理状态，提供了更灵活的状态管理方式。\",\"originAcceptText\":\"\\n- Pinia ：Pinia 可以在组件内使用，支持在组件内部管理状态，提供了更灵活的状态管理方式。\",\"originTextLength\":51,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":416,\"character\":50},\"end\":{\"line\":418,\"character\":41}},\"modifyRange\":{\"start\":{\"line\":416,\"character\":50},\"end\":{\"line\":418,\"character\":41}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n### 4. 更好的 TypeScript 支持\\\\n- Vuex ：Vuex 对 TypeScript 的支持较弱，需要手动定义类型。\",\"originAcceptText\":\"\\n### 4. 更好的 TypeScript 支持\\n- Vuex ：Vuex 对 TypeScript 的支持较弱，需要手动定义类型。\",\"originTextLength\":67,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":418,\"character\":41},\"end\":{\"line\":419,\"character\":53}},\"modifyRange\":{\"start\":{\"line\":418,\"character\":41},\"end\":{\"line\":419,\"character\":53}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Pinia ：Pinia 对 TypeScript 的支持更加完善，能够自动推断类型，提高了开发效率。\",\"originAcceptText\":\"\\n- Pinia ：Pinia 对 TypeScript 的支持更加完善，能够自动推断类型，提高了开发效率。\",\"originTextLength\":54,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":419,\"character\":53},\"end\":{\"line\":421,\"character\":32}},\"modifyRange\":{\"start\":{\"line\":419,\"character\":53},\"end\":{\"line\":421,\"character\":32}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n### 5. 更易用的插件系统\\\\n- Vuex ：Vuex 的插件系统相对复杂，需要手动注册插件。\",\"originAcceptText\":\"\\n### 5. 更易用的插件系统\\n- Vuex ：Vuex 的插件系统相对复杂，需要手动注册插件。\",\"originTextLength\":49,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":421,\"character\":32},\"end\":{\"line\":422,\"character\":41}},\"modifyRange\":{\"start\":{\"line\":421,\"character\":32},\"end\":{\"line\":422,\"character\":41}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Pinia ：Pinia 的插件系统更易用，只需要在 store 中引入即可。\",\"originAcceptText\":\"\\n- Pinia ：Pinia 的插件系统更易用，只需要在 store 中引入即可。\",\"originTextLength\":42,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":422,\"character\":41},\"end\":{\"line\":423,\"character\":12}},\"modifyRange\":{\"start\":{\"line\":422,\"character\":41},\"end\":{\"line\":423,\"character\":12}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n### 6. 更好的性能\",\"originAcceptText\":\"\\n### 6. 更好的性能\",\"originTextLength\":13,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":423,\"character\":12},\"end\":{\"line\":424,\"character\":38}},\"modifyRange\":{\"start\":{\"line\":423,\"character\":12},\"end\":{\"line\":424,\"character\":38}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Vuex ：Vuex 在大型应用中可能会有性能问题，特别是在大型应用中。\",\"originAcceptText\":\"\\n- Vuex ：Vuex 在大型应用中可能会有性能问题，特别是在大型应用中。\",\"originTextLength\":39,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":424,\"character\":38},\"end\":{\"line\":425,\"character\":41}},\"modifyRange\":{\"start\":{\"line\":424,\"character\":38},\"end\":{\"line\":425,\"character\":41}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n- Pinia ：Pinia 采用了更高效的响应式系统，在大型应用中性能表现更好。\",\"originAcceptText\":\"\\n- Pinia ：Pinia 采用了更高效的响应式系统，在大型应用中性能表现更好。\",\"originTextLength\":42,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":428,\"character\":73},\"end\":{\"line\":429,\"character\":88}},\"modifyRange\":{\"start\":{\"line\":428,\"character\":73},\"end\":{\"line\":429,\"character\":88}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n1. 嵌套副作用的管理 ：在 Vue 2 中，嵌套的副作用可能会导致难以管理的依赖关系。例如，在一个组件中，可能有多个嵌套的副作用，这些副作用可能相互依赖，导致难以跟踪和清理。\",\"originAcceptText\":\"\\n\\n1. 嵌套副作用的管理 ：在 Vue 2 中，嵌套的副作用可能会导致难以管理的依赖关系。例如，在一个组件中，可能有多个嵌套的副作用，这些副作用可能相互依赖，导致难以跟踪和清理。\",\"originTextLength\":90,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":430,\"character\":88},\"end\":{\"line\":431,\"character\":104}},\"modifyRange\":{\"start\":{\"line\":430,\"character\":88},\"end\":{\"line\":431,\"character\":104}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n2. 批量停止副作用 ：在 Vue 2 中，手动停止副作用可能会导致一些副作用无法正确停止。例如，在一个组件中，可能有多个嵌套的副作用，其中一些副作用可能已经停止，但是其他副作用仍然在运行，导致无法正确停止。\",\"originAcceptText\":\"\\n2. 批量停止副作用 ：在 Vue 2 中，手动停止副作用可能会导致一些副作用无法正确停止。例如，在一个组件中，可能有多个嵌套的副作用，其中一些副作用可能已经停止，但是其他副作用仍然在运行，导致无法正确停止。\",\"originTextLength\":105,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":431,\"character\":104},\"end\":{\"line\":433,\"character\":5}},\"modifyRange\":{\"start\":{\"line\":431,\"character\":104},\"end\":{\"line\":433,\"character\":5}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\n\\\\n## 21.1. 嵌套副作用的管理\\\\n```js\",\"originAcceptText\":\"\\n\\n## 21.1. 嵌套副作用的管理\\n```js\",\"originTextLength\":25,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":434,\"character\":5},\"end\":{\"line\":435,\"character\":42}},\"modifyRange\":{\"start\":{\"line\":434,\"character\":5},\"end\":{\"line\":435,\"character\":42}},\"action\":\"None\",\"isLine\":false,\"originText\":\"\\\\nimport { effectScope, effect } from \\\\'vue\\\\';\",\"originAcceptText\":\"\\nimport { effectScope, effect } from 'vue';\",\"originTextLength\":43,\"intentType\":\"Completion\"},{\"originRange\":{\"start\":{\"line\":436,\"character\":1},\"end\":{\"line\":437,\"character\":42}},\"modifyRange\":{\"start\":{\"line\":436,\"character\":1},\"end\":{\"line\":437,\"character\":42}},\"action\":\"None\",\"isLine\":false,\"originText\":\"··js\\\\nimport { effectScope, effect } from \\\\'vue\\\\';\",\"originAcceptText\":\"··js\\nimport { effectScope, effect } from 'vue';\",\"originTextLength\":47,\"intentType\":\"Completion\"}]"
}